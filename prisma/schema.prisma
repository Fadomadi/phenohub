generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Cultivar {
  id          Int                @id @default(autoincrement())
  name        String
  slug        String             @unique
  aka         String[]           @default([])
  cloneOnly   Boolean            @default(false)
  cutInfo     String?
  reportCount Int                @default(0)
  avgRating   Decimal            @default(0.0)
  imageCount  Int                @default(0)
  trending    Boolean            @default(false)
  thumbnails  String[]           @default([])
  description String?
  genetics    String?
  flavorProfile String?
  aromaProfile String?
  floweringTime String?
  yieldPotential String?
  effectProfile String?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  breeder     String?
  offerings   CultivarOffering[]
  reports     Report[]
}

model Provider {
  id            Int                @id @default(autoincrement())
  name          String
  slug          String             @unique
  country       String
  countryFlag   String
  avgScore      Decimal            @default(0.0)
  reportCount   Int                @default(0)
  shippingScore Decimal            @default(0.0)
  vitalityScore Decimal            @default(0.0)
  website       String?
  bio           String?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  offerings     CultivarOffering[]
  reports       Report[]
}

model Report {
  id             Int             @id @default(autoincrement())
  title          String
  slug           String          @unique
  excerpt        String
  content        String?
  authorHandle   String
  shipping       Decimal         @default(0.0)
  vitality       Decimal         @default(0.0)
  stability      Decimal         @default(0.0)
  overall        Decimal         @default(0.0)
  likes          Int             @default(0)
  comments       Int             @default(0)
  views          Int             @default(0)
  images         String[]        @default([])
  gallery        Json?
  publishedAt    DateTime?       @db.Timestamptz(6)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  cultivarId     Int
  providerId     Int
  authorId       Int?
  moderatedAt    DateTime?       @db.Timestamptz(6)
  moderatedById  Int?
  reviewNote     String?
  status         ReportStatus    @default(PENDING)
  additionalInfo Json?
  interactions   Interaction[]
  author         User?           @relation(fields: [authorId], references: [id])
  cultivar       Cultivar        @relation(fields: [cultivarId], references: [id])
  moderatedBy    User?           @relation("ModeratedReports", fields: [moderatedById], references: [id])
  provider       Provider        @relation(fields: [providerId], references: [id], onDelete: Cascade)
  commentEntries ReportComment[]
  likedBy        ReportLike[]
}

model CultivarOffering {
  id         Int      @id @default(autoincrement())
  cultivarId Int
  providerId Int
  priceEur   Decimal? @default(0.0)
  category   String?
  terpenes   Json?
  notes      String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  cultivar   Cultivar @relation(fields: [cultivarId], references: [id], onDelete: Cascade)
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@unique([providerId, cultivarId])
}

model User {
  id               Int              @id @default(autoincrement())
  email            String           @unique
  name             String?
  username         String?          @unique
  image            String?
  role             UserRole         @default(USER)
  bio              String?
  plan             SubscriptionTier @default(FREE)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  stripeCustomerId String?
  lastLoginAt      DateTime?
  passwordHash     String?
  status           UserStatus       @default(ACTIVE)
  verifiedAt       DateTime?
  accounts         Account[]
  interactions     Interaction[]
  reports          Report[]
  moderatedReports Report[]         @relation("ModeratedReports")
  comments         ReportComment[]
  likedReports     ReportLike[]
  sessions         Session[]
  highlightFeedbacks HighlightFeedback[]
  subscriptions    Subscription[]
}

model Subscription {
  id                Int                @id @default(autoincrement())
  stripeSubId       String             @unique
  status            SubscriptionStatus @default(ACTIVE)
  tier              SubscriptionTier   @default(STARTER)
  currentPeriodEnd  DateTime
  cancelAtPeriodEnd Boolean            @default(false)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  userId            Int
  user              User               @relation(fields: [userId], references: [id])
}

model Interaction {
  id        Int             @id @default(autoincrement())
  type      InteractionType
  createdAt DateTime        @default(now())
  metadata  Json?
  userId    Int?
  reportId  Int?
  report    Report?         @relation(fields: [reportId], references: [id], onDelete: Cascade)
  user      User?           @relation(fields: [userId], references: [id])
}

model ReportLike {
  id        Int      @id @default(autoincrement())
  reportId  Int
  userId    Int?
  clientId  String?
  createdAt DateTime @default(now())
  report    Report   @relation(fields: [reportId], references: [id], onDelete: Cascade)
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reportId, userId], map: "unique_report_user_like")
  @@unique([reportId, clientId], map: "unique_report_client_like")
}

model ReportComment {
  id         Int      @id @default(autoincrement())
  reportId   Int
  userId     Int?
  authorName String
  body       String
  createdAt  DateTime @default(now())
  report     Report   @relation(fields: [reportId], references: [id], onDelete: Cascade)
  user       User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([reportId], map: "idx_report_comment_report")
  @@index([userId], map: "idx_report_comment_user")
}

model HighlightFeedback {
  id         Int      @id @default(autoincrement())
  body       String
  createdAt  DateTime @default(now())
  userId     Int?
  authorName String
  archivedAt DateTime?
  user       User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt], map: "idx_highlight_feedback_created_at")
  @@index([userId], map: "idx_highlight_feedback_user")
  @@index([archivedAt], map: "idx_highlight_feedback_archived_at")
}

model Account {
  id                Int      @id @default(autoincrement())
  userId            Int
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       Int
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model SiteSetting {
  id        Int      @id @default(autoincrement())
  key       String   @unique
  value     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())

  @@unique([identifier, token])
}

model SupporterWaitlist {
  id                 Int                     @id @default(autoincrement())
  email              String                  @unique
  status             SupporterWaitlistStatus @default(PENDING)
  source             String?
  confirmationSentAt DateTime?
  confirmedAt        DateTime?
  createdAt          DateTime                @default(now())
  updatedAt          DateTime                @updatedAt
}

enum InteractionType {
  LIKE
  COMMENT
  VIEW
}

enum SupporterWaitlistStatus {
  PENDING
  CONFIRMED
  UNSUBSCRIBED
}

enum SubscriptionStatus {
  ACTIVE
  INCOMPLETE
  TRIALING
  PAST_DUE
  CANCELED
}

enum SubscriptionTier {
  FREE
  STARTER
  PRO
  ENTERPRISE
  CUSTOM
}

enum UserRole {
  USER
  SUPPORTER
  VERIFIED
  MODERATOR
  ADMIN
  OWNER
}

enum UserStatus {
  ACTIVE
  INVITED
  SUSPENDED
}

enum ReportStatus {
  PENDING
  PUBLISHED
  REJECTED
}
